% Generated by roxygen2 (4.0.2): do not edit by hand
\name{krige.conv}
\alias{krige.conv}
\title{cost-based kriging}
\usage{
krige.conv(geodata, coords = geodata$coords, data = geodata$data, locations,
  borders, krige, output, dd.dists.mat, dl.dists.mat)
}
\description{
All the arguments work as in \code{\link[geoR]{krige.conv}}, except the
additional arguments \code{dd.dists.mat} and \code{dl.dists.mat},
which take matrices of distances between observation locations and
between observations and prediction locations respectively
}
\examples{
## geodata structure with transformed covariates
data(noise)
covarnames=sapply(1:3, function(x) paste("d2TV", x, sep=""))
obs.df <- data.frame(Leq=obs$Leq,
                     1/(1+(as.data.frame(obs)[covarnames]/20)^2))
obs.gd <- as.geodata(cbind(coordinates(obs), obs.df),
                     data.col="Leq",
                     covar.col=c('d2TV1','d2TV2','d2TV3'))
trend=~d2TV1*(d2TV2+d2TV3)

loc1.df <- as.data.frame(1/(1+(as.data.frame(loc)[covarnames]/20)^2))


# With trend, Euclidean distances
# NOTE: The Euclidean prediction is done with cost-based covariates
KC.std = krige.control(trend.d=trend,
                       trend.l=~loc1.df$d2TV1*(loc1.df$d2TV2+loc1.df$d2TV3),
                       obj.model=vgmdl.std)
kc1.std<-krige.conv(obs.gd,locations=coordinates(loc), krige=KC.std)

# With trend, Cost-based distances
KC = krige.control(trend.d=trend,
                   trend.l=~loc1.df$d2TV1*(loc1.df$d2TV2+loc1.df$d2TV3),
                   obj.model=vgmdl.dmat)
kc1<-krige.conv(obs.gd,locations=coordinates(loc), krige=KC,
                dd.dists.mat=dd.distmat, dl.dists.mat=dl.distmat)
}

