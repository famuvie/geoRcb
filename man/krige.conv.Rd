% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/kriging.R
\name{krige.conv}
\alias{krige.conv}
\title{cost-based kriging}
\usage{
krige.conv(geodata, coords = geodata$coords, data = geodata$data, locations,
  borders, krige, output, dd.dists.mat, dl.dists.mat)
}
\arguments{
\item{geodata}{a list containing elements \code{coords} and
    \code{data} as described next. Typically an object of the \code{\link{class}}
    \code{"geodata"} - a \pkg{geoR} data-set. If not provided the arguments
    \code{coords} and \code{data} must be provided instead.  }

\item{coords}{an \eqn{n \times 2}{n x 2} matrix or data-frame with the 2-D
    coordinates of the \eqn{n} data locations.
    By default it takes the
    component \code{coords} of the argument \code{geodata}, if provided.  }

\item{data}{a vector with \emph{n} data values. By default it takes the
    component \code{data} of the argument \code{geodata}, if provided.  }

\item{locations}{an \eqn{N \times 2}{N x 2} matrix or data-frame with the 2-D
    coordinates of the \eqn{N} prediction locations, or a list for which
    the first two components are used. Input is internally checked by the
    function \code{check.locations}.  }

\item{borders}{optional. By default reads the element \code{borders}
    from the \code{geodata} object, if present.
    Setting to \code{NULL} prevents this behavior.
    If a two column matrix defining a polygon is
    provided the prediction is performed only at locations inside this polygon. }

\item{krige}{a list defining the model components and the type of
    kriging. It can take an output to a call to \code{krige.control} or
    a list with elements as for the arguments in \code{krige.control}.
    Default values are assumed for arguments  or list elements not provided.
    See the description of arguments in `krige.control' below.  }

\item{output}{a list specifying output options.
    It can take an output to a call to \code{output.control} or
    a list with elements as for the arguments in \code{output.control}.
    Default values are assumed for arguments not provided.
    See documentation for
    \code{\link{output.control}} for further details.  }

\item{dd.dists.mat}{n x n symmetric matrix with cost-based distances between
observations}

\item{dl.dists.mat}{m x n matrix with cost-based distances from each
observation to each one of the m prediction locations}
}
\description{
All the arguments work as in \code{\link[geoR]{krige.conv}}, except the
additional arguments \code{dd.dists.mat} and \code{dl.dists.mat}, which take
matrices of distances between observation locations and between observations
and prediction locations respectively
}
\examples{
## geodata structure with transformed covariates
data(noise)
covarnames=sapply(1:3, function(x) paste("d2TV", x, sep=""))
obs.df <- data.frame(Leq=obs$Leq,
                     1/(1+(as.data.frame(obs)[covarnames]/20)^2))
obs.gd <- as.geodata(cbind(coordinates(obs), obs.df),
                     data.col="Leq",
                     covar.col=c('d2TV1','d2TV2','d2TV3'))
trend=~d2TV1*(d2TV2+d2TV3)

loc1.df <- as.data.frame(1/(1+(as.data.frame(loc)[covarnames]/20)^2))

## fitting variogram models
vgmdl.std  <- likfit(geodata = obs.gd, trend=trend,
                     ini = c(8,300), cov.model = "matern")
vgmdl.dmat <- likfit(geodata = obs.gd, trend=trend,
                     ini = c(8,300), cov.model = "matern",
                     dists.mat=dd.distmat)


# With trend, Euclidean distances
# NOTE: The Euclidean prediction is done with cost-based covariates
KC.std = krige.control(trend.d=trend,
                       trend.l=~loc1.df$d2TV1*(loc1.df$d2TV2+loc1.df$d2TV3),
                       obj.model=vgmdl.std)
kc1.std<-krige.conv(obs.gd,locations=coordinates(loc), krige=KC.std)

# With trend, Cost-based distances
KC = krige.control(trend.d=trend,
                   trend.l=~loc1.df$d2TV1*(loc1.df$d2TV2+loc1.df$d2TV3),
                   obj.model=vgmdl.dmat)
kc1<-krige.conv(obs.gd,locations=coordinates(loc), krige=KC,
                dd.dists.mat=dd.distmat, dl.dists.mat=dl.distmat)
}

